/*
   sostituita la libreria del display.
 */
#include <Arduino.h>
#include <ClickEncoder.h>
#include <Menu.h>

#include <TFT_eSPI.h>

// ----------------------------------------------------------------------------
// helpers

class ScopedTimer
{
      public:
        ScopedTimer(const char *Label)
            : label(Label), ts(millis())
        {
        }
        ~ScopedTimer()
        {
                Serial.print(label);
                Serial.print(": ");
                Serial.println(millis() - ts);
        }

      private:
        const char *label;
        const unsigned long ts;
};

#define clampValue(val, lo, hi) \
        if (val > hi)           \
                val = hi;       \
        if (val < lo)           \
                val = lo;
#define maxValue(a, b) ((a > b) ? a : b)
#define minValue(a, b) ((a < b) ? a : b)

// encoder

//ClickEncoder Encoder(A0, A1, A2, 2);
ClickEncoder Encoder(PIN_D11, PIN_D12, PIN_D1, D2);

//display

//TFT_eSPI display();
TFT_eSPI display(128, 160);

// ----------------------------------------------------------------------------

Menu::Engine *engine;

// ----------------------------------------------------------------------------

// namespace State {
// typedef enum SystemMode_e {
//         None      = 0,
//         Default   = (1<<0),
//         Settings  = (1<<1),
//         Edit      = (1<<2)
// } SystemMode;
// };
namespace State
{
typedef enum SystemMode_e {
        None = 0,
        Default = 1,
        Settings = 2,
        Edit = 3,
        sergio = 4
} SystemMode;
};

uint8_t systemState = State::Default;
bool lastEncoderAccelerationState = true;
uint8_t previousSystemState = State::None;

// ----------------------------------------------------------------------------
bool menuExit(const Menu::Action_t b)
{
        Encoder.setAccelerationEnabled(lastEncoderAccelerationState);
        systemState = State::Default;
        return true;
}

bool menuDummy(const Menu::Action_t a)
{
        return true;
}

bool menuBack(const Menu::Action_t a)
{
        if (a == Menu::actionDisplay)
        {
                engine->navigate(engine->getParent(engine->getParent()));
        }
        return true;
}

//aggiunta da me
bool custom(const Menu::Action_t a)
{
        if (a == Menu::actionDisplay)
        {
                systemState = State::sergio;
        }
        return true;
}

// ----------------------------------------------------------------------------

uint8_t menuItemsVisible = 5;
uint8_t menuItemHeight = 12;

void renderMenuItem(const Menu::Item_t *mi, uint8_t pos)
{
        //ScopedTimer tm("  render menuitem");

        uint8_t y = pos * menuItemHeight + 2;

        display.setCursor(10, y);

        // a cursor
        display.drawRect(8, y - 2, 90, menuItemHeight, (engine->currentItem == mi) ? TFT_WHITE : TFT_BLACK);
        display.print(engine->getLabel(mi));

        // mark items that have children
        if (engine->getChild(mi) != &Menu::NullItem)
        {
                display.print(" >   ");
        }
}

// ----------------------------------------------------------------------------
/* Struttura della demo

   miExit
   miSettings
    CalibrateHI
    calibrateLo
    Channel0
      miChannel1
      miChScale1
    Channel1
      miChannel1
      miChScale1
      miChBack1
   miTest1
   miTest2
   miTest3
   miTest4
   miTest5
   miTest6
   miTest7
 */
// Name, Label, Next, Previous, Parent, Child, Callback
MenuItem(miDashboard, "Dashboard", Menu::NullItem, Menu::NullItem, Menu::NullItem, miControl, menuExit);
MenuItem(miControl, "Wave Controll", miSettings, Menu::NullItem, miDashboard, miWform, menuDummy);
MenuItem(miWform, "Wafeform choose", Menu::NullItem, Menu::NullItem, miControl, Menu::NullItem, menuDummy);
MenuItem(miSettings, "Settings", miCalibrate, miControl, miDashboard, miXXX, menuDummy);
MenuItem(miXXX, "XXX", miYYY, Menu::NullItem, miSettings, Menu::NullItem, menuDummy);
MenuItem(miYYY, "YYY", miZZZ, miXXX, miSettings, Menu::NullItem, menuDummy);
MenuItem(miZZZ, "ZZZ", Menu::NullItem, miYYY, miSettings, Menu::NullItem, custom);
MenuItem(miCalibrate, "Calbrate", Menu::NullItem, miSettings, miDashboard, Menu::NullItem, menuDummy);
MenuItem(dummy0, "dummy", dummy1, Menu::NullItem, miDashboard, Menu::NullItem, menuDummy);
MenuItem(dummy1, "dummy", dummy2, dummy0, miDashboard, Menu::NullItem, menuDummy);
MenuItem(dummy2, "dummy", dummy3, dummy1, miDashboard, Menu::NullItem, menuDummy);
MenuItem(dummy3, "dummy", Menu::NullItem, dummy2, miDashboard, Menu::NullItem, menuDummy);

// ----------------------------------------------------------------------------

void setup()
{
        Serial.begin(115200);
        Serial.print("Starting...");

        
        display.init();
        delay(2000);
        display.fillScreen(TFT_BLACK),

            display.setTextWrap(false);
        display.setTextSize(1);
        //tft.setRotation(3);

        //Timer1.initialize(1000);
        //Timer1.attachInterrupt(timerIsr);

        // pinMode(MISO, OUTPUT);
        // pinMode(MOSI, OUTPUT);
        // // enable pull up, otherwise display flickers
        // PORTB |= (1 << MOSI) | (1 << MISO);

        engine = new Menu::Engine(&Menu::NullItem);
        menuExit(Menu::actionDisplay); // reset to initial state
}

// ----------------------------------------------------------------------------

int16_t encMovement;
int16_t encAbsolute;
int16_t encLastAbsolute = -1;
bool updateMenu = false;

// ----------------------------------------------------------------------------
void encoderService()
{
        static int last = 0;
        if ((last - millis()) < 5)
        {
                last = millis();
                Encoder.service();
        }
        if (last-millis()< 2000) {
          Serial.println("Running...");
        }
}
void loop()
{
        encoderService();

        // handle encoder
        encMovement = Encoder.getValue();
        if (encMovement)
        {
                encAbsolute += encMovement;

                if (systemState == State::Settings)
                {
                        engine->navigate((encMovement > 0) ? engine->getNext() : engine->getPrev());
                        updateMenu = true;
                }
        }

        // handle button
        switch (Encoder.getButton())
        {

        case ClickEncoder::Clicked:
                if (systemState == State::Settings)
                {
                        engine->invoke();
                        updateMenu = true;
                }
                break;

        case ClickEncoder::DoubleClicked:
                if (systemState == State::Settings)
                {
                        engine->navigate(engine->getParent());
                        updateMenu = true;
                }
                else if (systemState == State::sergio)
                {
                        engine->navigate(&miDashboard);
                        updateMenu = true; //vediamo che fa...
                }

                if (systemState == State::Default)
                {
                        Encoder.setAccelerationEnabled(!Encoder.getAccelerationEnabled());
                        display.setTextSize(1);
                        display.setCursor(10, 42);
                        display.print("Acceleration: ");
                        display.print((Encoder.getAccelerationEnabled()) ? "on " : "off");
                }
                if (systemState == State::sergio)
                {
                        engine->navigate(engine->getParent());
                        //engine->navigate()
                }
                break;

        case ClickEncoder::Held:
                if (systemState != State::Settings)
                { // enter settings menu

                        // disable acceleration, reset in menuExit()
                        lastEncoderAccelerationState = Encoder.getAccelerationEnabled();
                        Encoder.setAccelerationEnabled(false);

                        display.fillScreen(TFT_BLACK);
                        display.setTextColor(TFT_WHITE, TFT_BLACK);

                        engine->navigate(&miSettings);

                        systemState = State::Settings;
                        previousSystemState = systemState;
                        updateMenu = true;
                }
                break;
        }

        if (updateMenu)
        { //si innesca ognivolta che updateMenu cambia in true
                updateMenu = false;

                if (!encMovement)
                { // clear menu on child/parent navigation
                        display.fillRect(8, 1, 120, 100, TFT_BLACK);
                }

                // simple scrollbar
                Menu::Info_t mi = engine->getItemInfo(engine->currentItem);
                uint8_t sbTop = 0, sbWidth = 4, sbLeft = 100;
                uint8_t sbItems = minValue(menuItemsVisible, mi.siblings);
                uint8_t sbHeight = sbItems * menuItemHeight;
                uint8_t sbMarkHeight = sbHeight * sbItems / mi.siblings;
                uint8_t sbMarkTop = ((sbHeight - sbMarkHeight) / mi.siblings) * (mi.position - 1);
                display.fillRect(sbLeft, sbTop, sbWidth, sbHeight, TFT_WHITE);
                display.fillRect(sbLeft, sbMarkTop, sbWidth, sbMarkHeight, TFT_WHITE);

// debug scrollbar values
#if 0
                        char buf[30];
                        sprintf(buf, "itms: %d, h: %d, mh: %d, mt: %d", sbItems, sbHeight, sbMarkHeight, sbMarkTop);
                        Serial.println(buf);
#endif

                // render the menu
                {
                        ScopedTimer tm("render menu");
                        engine->render(renderMenuItem, menuItemsVisible);
                }

                {
                        //ScopedTimer tm("helptext");
                        display.setTextSize(1);
                        display.setCursor(5, 55);
                        display.print("Doubleclick to ");
                        if (engine->getParent() == &miDashboard)
                        {
                                display.print("exit. ");
                        }
                        else
                        {
                                display.print("go up.");
                        }
                }
        }

        // dummy "application"
        if (systemState == State::Default)
        {
                if (systemState != previousSystemState)
                {
                        previousSystemState = systemState;
                        encLastAbsolute = -999; // force updateMenu
                        display.fillScreen(TFT_WHITE);
                        display.setTextColor(TFT_BLACK, TFT_WHITE);
                        display.setCursor(5, 5);
                        display.setTextSize(2);
                        display.print("Dashboard");

                        display.setTextSize(1);
                        display.setCursor(5, 55);
                        display.print("Hold button for setup");
                }

                if (encAbsolute != encLastAbsolute)
                {
                        encLastAbsolute = encAbsolute;
                        display.setCursor(5, 30);
                        display.setTextSize(1);
                        display.print("Frequency:");
                        display.setCursor(70, 30);
                        char tmp[10];
                        sprintf(tmp, "%4d", encAbsolute);
                        display.print(tmp);
                }
        }
        if (systemState == State::sergio)
        {
                if (systemState != previousSystemState)
                {
                        previousSystemState = systemState;
                        display.fillScreen(TFT_BLACK),

                            display.setCursor(5, 5);
                        display.print("Demo");
                        display.fillTriangle(20, 45, 40, 12, 110, 60, TFT_WHITE);
                }
        }
}
